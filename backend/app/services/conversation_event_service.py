# backend/app/services/conversation_event_service.py
import asyncio
from datetime import datetime
import logging
from typing import TYPE_CHECKING

from app.api.websockets import manager as websocket_manager
from app.core.transcript import transcript_store

if TYPE_CHECKING:
    from app.simulation.agents import SimulatedAgent

logger = logging.getLogger(__name__)

class ConversationEventService:
    def __init__(self, transcript_store, ws_manager):
        self.transcript_store = transcript_store
        self.ws_manager = ws_manager
        self.relative_timestamp = 0.0 # Simple way to track time for sims

    async def handle_simulated_utterance(self, agent: 'SimulatedAgent', text: str):
        """
        Handles an utterance generated by the simulation engine.
        1. Adds it to the TranscriptStore.
        2. Broadcasts it to the UI.
        """
        logger.info(f"Handling simulated utterance from {agent['name']}")

        # 1. Add to TranscriptStore
        # We'll add a new method to TranscriptStore for this (see Step 2)
        segment = self.transcript_store.add_simulated_utterance(
            participant_name=agent['name'],
            text=text
        )

        # 2. Broadcast to UI
        payload = {
            "type": "transcript_update",
            "event": "final", # Simulated text is always final
            "participant": agent['name'],
            "text": text,
            "color": agent['color'],
            "timestamp": datetime.now().isoformat()
        }
        await self.ws_manager.broadcast(payload)
        return segment

    async def handle_recall_transcript_data(self, payload: dict):
        """
        Handles a transcript payload from the Recall.ai webhook.
        1. Adds it to the TranscriptStore.
        2. Broadcasts it to the UI.
        """
        event_type = payload.get("event")
        if event_type not in ["transcript.data", "transcript.partial_data"]:
            return

        is_final = event_type == "transcript.data"
        logger.info(f"Handling Recall transcript data (final={is_final})")

        # 1. Add to TranscriptStore
        if is_final:
            self.transcript_store.add_transcript_data(payload)
        else:
            self.transcript_store.add_partial_transcript_data(payload)

        # 2. Broadcast to UI
        data = payload.get("data", {}).get("data", {})
        participant = data.get("participant", {})
        text = " ".join(w.get("text", "") for w in data.get("words", []))

        broadcast_payload = {
            "type": "transcript_update",
            "event": "final" if is_final else "partial",
            "participant": participant.get("name", "Unknown"),
            "text": text
        }
        await self.ws_manager.broadcast(broadcast_payload)

# Create a singleton instance
conversation_event_service = ConversationEventService(transcript_store, websocket_manager)