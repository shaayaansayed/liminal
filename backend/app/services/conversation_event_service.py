# backend/app/services/conversation_event_service.py
import asyncio
from datetime import datetime
import logging
from typing import TYPE_CHECKING

from app.api.websockets import manager as websocket_manager
from app.core.transcript import transcript_store

if TYPE_CHECKING:
    from app.simulation.agents import SimulatedAgent

logger = logging.getLogger(__name__)

class ConversationEventService:
    def __init__(self, transcript_store, ws_manager):
        self.transcript_store = transcript_store
        self.ws_manager = ws_manager
        self.relative_timestamp = 0.0 # Simple way to track time for sims

    async def handle_simulated_utterance(self, agent: 'SimulatedAgent', text: str):
        """
        Handles an utterance generated by the simulation engine.
        1. Adds it to the TranscriptStore.
        2. Broadcasts it to the UI in a format the frontend understands.
        """
        logger.info(f"Handling simulated utterance from {agent['name']}")

        # 1. Add to TranscriptStore
        segment = self.transcript_store.add_simulated_utterance(
            participant_name=agent['name'],
            text=text
        )

        # 2. Broadcast to UI using the 'transcript_segment_append' format
        # This aligns with what the frontend expects for new, final transcript data.
        broadcast_payload = {
            "type": "transcript_segment_append",
            "data": {
                "id": segment.id,
                "participant_id": segment.participant_id,
                "participant_name": segment.participant_name,
                "text": " ".join(word.text for word in segment.words),
                "is_partial": segment.is_partial,  # This will be False
                "timestamp": segment.timestamp.isoformat()
            }
        }
        logger.info(f"Broadcasting simulated segment append for segment {segment.id}")
        await self.ws_manager.broadcast(broadcast_payload)
        return segment

    async def handle_recall_transcript_data(self, payload: dict):
        """
        Handles a transcript payload from the Recall.ai webhook.
        1. Adds it to the TranscriptStore.
        2. Broadcasts it to the UI.
        """
        event_type = payload.get("event")
        if event_type not in ["transcript.data", "transcript.partial_data"]:
            return

        logger.info(f"Handling Recall transcript data (event: {event_type})")

        # 1. Add to TranscriptStore using the new unified method
        result = self.transcript_store.add_transcript_from_webhook(payload)
        if result is None:
            return
            
        action_type, segment, deleted_segment_id = result
        
        # 2. Broadcast to UI based on action type
        if action_type == "APPEND":
            # New segment added
            broadcast_payload = {
                "type": "transcript_segment_append",
                "data": {
                    "id": segment.id,
                    "participant_id": segment.participant_id,
                    "participant_name": segment.participant_name,
                    "text": " ".join(word.text for word in segment.words),
                    "is_partial": segment.is_partial,
                    "timestamp": segment.timestamp.isoformat()
                }
            }
            logger.info(f"Broadcasting segment append for segment {segment.id}")
            
        elif action_type == "UPDATE":
            # Partial segment updated
            broadcast_payload = {
                "type": "transcript_segment_update",
                "data": {
                    "id": segment.id,
                    "participant_id": segment.participant_id,
                    "participant_name": segment.participant_name,
                    "text": " ".join(word.text for word in segment.words),
                    "is_partial": segment.is_partial,
                    "timestamp": segment.timestamp.isoformat()
                }
            }
            logger.info(f"Broadcasting segment update for segment {segment.id}")
            
        elif action_type == "FINALIZE":
            # Partial segment finalized
            broadcast_payload = {
                "type": "transcript_segment_finalize",
                "data": {
                    "id": segment.id,
                    "participant_id": segment.participant_id,
                    "participant_name": segment.participant_name,
                    "text": " ".join(word.text for word in segment.words),
                    "is_partial": segment.is_partial,
                    "timestamp": segment.timestamp.isoformat()
                }
            }
            logger.info(f"Broadcasting segment finalize for segment {segment.id}")
            
        elif action_type == "MERGE_UPDATE":
            # Segment merged with another
            broadcast_payload = {
                "type": "transcript_segment_merge_update",
                "data": {
                    "id": segment.id,
                    "participant_id": segment.participant_id,
                    "participant_name": segment.participant_name,
                    "text": " ".join(word.text for word in segment.words),
                    "is_partial": segment.is_partial,
                    "timestamp": segment.timestamp.isoformat(),
                    "deleted_segment_id": deleted_segment_id
                }
            }
            logger.info(f"Broadcasting segment merge update for segment {segment.id}, deleting {deleted_segment_id}")
            
        await self.ws_manager.broadcast(broadcast_payload)

# Create a singleton instance
conversation_event_service = ConversationEventService(transcript_store, websocket_manager)